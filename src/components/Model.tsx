/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import {
  useGLTF,
  PerspectiveCamera,
  useAnimations,
  useScroll,
} from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";

type ActionName = "CameraAction";
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.Mesh;
    Sphere: THREE.Mesh;
    Cone: THREE.Mesh;
    Suzanne: THREE.Mesh;
    Sphere002: THREE.Mesh;
    Sphere001: THREE.Mesh;
  };
  materials: {
    Cube: THREE.MeshStandardMaterial;
    Sphere: THREE.MeshStandardMaterial;
    Cone: THREE.MeshStandardMaterial;
    Suzane: THREE.MeshStandardMaterial;
    Drop: THREE.MeshStandardMaterial;
    ["Material.001"]: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

interface TrackData {
  times: Float32Array;
  values: any[];
}

function parseTrackDataAsVector3(track: THREE.VectorKeyframeTrack) {
  let data: TrackData = { times: track.times, values: [] };
  for (let i = 0; i < track.values.length; i += 3) {
    data.values.push(
      new THREE.Vector3(
        track.values[i],
        track.values[i + 1],
        track.values[i + 2]
      )
    );
  }

  return data;
}

function parseTrackDataAsQuaternion(track: THREE.VectorKeyframeTrack) {
  let data: TrackData = { times: track.times, values: [] };
  for (let i = 0; i < track.values.length; i += 4) {
    data.values.push(
      new THREE.Quaternion(
        track.values[i],
        track.values[i + 1],
        track.values[i + 2],
        track.values[i + 3]
      )
    );
  }

  return data;
}

export default function Model(props: JSX.IntrinsicElements["group"]) {
  const scroll = useScroll();
  const group = useRef<THREE.Group>();
  const { nodes, materials, animations } = useGLTF(
    "/Models/animation.gltf"
  ) as GLTFResult;
  const { actions } = useAnimations(animations, group);

  let position: TrackData;
  let rotation: TrackData;

  useEffect(() => {
    if (actions["CameraAction"]) {
      actions["CameraAction"].play().paused = true;
      position = parseTrackDataAsVector3(
        actions["CameraAction"].getClip().tracks[0]
      );

      rotation = parseTrackDataAsQuaternion(
        actions["CameraAction"].getClip().tracks[1]
      );

      console.log(actions["CameraAction"].getClip().tracks[0]);
    }
  }, []);

  useFrame((state, delta) => {
    if (actions["CameraAction"]) {
      const time = actions.CameraAction.getClip().duration * scroll.offset;
      for (let i = 0; i < position.times.length - 1; i++) {
        if (time >= position.times[i] && time < position.times[i + 1]) {
          state.camera.position.lerp(position.values[i], 0.05);
        } else if (time >= position.times[position.times.length - 1]) {
          state.camera.position.lerp(
            position.values[position.values.length - 1],
            0.05
          );
        }

        if (time >= rotation.times[i] && time < rotation.times[i + 1]) {
          state.camera.quaternion.slerp(rotation.values[i], 0.05);
        } else if (time >= rotation.times[rotation.times.length - 1]) {
          state.camera.quaternion.slerp(
            rotation.values[rotation.values.length - 1],
            0.05
          );
        }
      }
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Camera" position={[5.24, 15.04, 0.01]}>
        <group rotation={[Math.PI / 2, 0, -Math.PI / 2]}>
          <PerspectiveCamera
            makeDefault={false}
            far={1000}
            near={0.1}
            fov={22.9}
            rotation={[-Math.PI / 2, 0, 0]}
          />
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube.geometry}
        material={materials.Cube}
        position={[0, 15, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere.geometry}
        material={materials.Sphere}
        position={[-2.7, 9.16, 2.96]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cone.geometry}
        material={materials.Cone}
        position={[2.58, 4.54, -2.85]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Suzanne.geometry}
        material={materials.Suzane}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere002.geometry}
        material={materials.Drop}
        position={[-1.15, 12.9, 0.71]}
        rotation={[Math.PI / 2, 0.17, Math.PI / 2]}
        scale={[0.04, 0.04, 0.04]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere001.geometry}
        material={materials["Material.001"]}
        scale={[100, 100, 100]}
      />
    </group>
  );
}

useGLTF.preload("/Models/animation.gltf");
